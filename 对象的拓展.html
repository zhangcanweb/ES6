<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>ES6-对象</title>
</head>

<body>
	<script>
		//对象属性，方法简写
		let obj={
			name,//name:name
			['a'+'b']:123,
			call(){
				console.log(this.name)
			}
		}
		obj.name="kobe";
		obj.call();
		obj.ab=28;
		console.log(obj.ab);
		//注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。<br>
		const keyA = {a: 1};
		const keyB = {b: 2};
		const myObject = {
  			[keyA]: 'valueA',
  			[keyB]: 'valueB'
		};
		console.log(myObject); // Object {[object Object]: "valueB"}
		//name属性：方法的名字
		console.log(obj.call.name);//call
		//如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。
//		const obj = {
//  			get foo() {},
//  			set foo(x) {}
//		};

//obj.foo.name
// TypeError: Cannot read property 'name' of undefined
		console.log({}==={});//false
		//object.is():比较是否相等；
		//es5
		 +0 === -0 //true
		 NaN === NaN // false
		 //es6
		 Object.is(+0, -0) // false
		 Object.is(NaN, NaN) // true
		 //Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
		 var target = { a: 1,c:5};
		 var source1 = { b: 2 };
		 var source2 = { c: 3,a:4};
		 Object.assign(target, source1, source2);
		 console.log(target) // {a:4, b:2, c:3}
		 //属性的可枚举性和遍历：对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。
		console.log(Object.getOwnPropertyDescriptor(obj, 'name'));
		//  {
		//    value: 123,
		//    writable: true,
		//    enumerable: true,//值为false为不可枚举
		//    configurable: true
		//  }
		//目前，有四个操作会忽略enumerable为false的属性。
		//for...in循环：只遍历对象自身的和继承的可枚举的属性。
		//Object.keys()：返回对象自身的所有可枚举的属性的键名。
		//JSON.stringify()：只串行化对象自身的可枚举的属性。
		//Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。
		console.log(Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable);//false
		//Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。
	</script>
</body>
</html>
